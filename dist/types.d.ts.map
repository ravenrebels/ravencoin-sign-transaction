{"mappings":"AAQA;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,EAAE,MAAM,CAAC;CACf;AAED,qBACE,OAAO,EAAE,KAAK,GAAG,UAAU,GAAG,KAAK,GAAG,UAAU,EAChD,iBAAiB,EAAE,MAAM,EACzB,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,EACnB,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,GAClC,MAAM,CAuFR;;;;AAED,wBAEE","sources":["index.ts"],"sourcesContent":["import * as bitcoin from \"bitcoinjs-lib\";\nimport { ECPairFactory } from \"ecpair\";\nimport * as tinysecp from \"tiny-secp256k1\";\n\nimport { rvn, evr, toBitcoinJS, MainNet, TestNet } from \"@hyperbitjs/chains\";\n\nconst ECPair = ECPairFactory(tinysecp);\n\ninterface IUTXO {\n  address: string;\n  assetName: string;\n  txid: string;\n  outputIndex: number;\n  script: string;\n  satoshis: number;\n  height?: number;\n  value: number;\n}\n\nexport function sign(\n  network: \"rvn\" | \"rvn-test\" | \"evr\" | \"evr-test\",\n  rawTransactionHex: string,\n  UTXOs: Array<IUTXO>,\n  privateKeys: Record<string, string>\n): string {\n  const networkMapper = {\n    rvn: toBitcoinJS(rvn.mainnet as MainNet),\n    \"rvn-test\": toBitcoinJS(rvn.testnet as TestNet),\n    evr: toBitcoinJS(evr.mainnet as MainNet),\n    \"evr-test\": toBitcoinJS(evr.testnet as TestNet),\n  };\n\n  const COIN = networkMapper[network];\n  COIN.bech32 = COIN.bech32 || \"\"; //ECPair requires bech32 to not be undefined\n  if (!COIN) throw new Error(\"Invalid network specified\");\n\n  const COIN_NETWORK = COIN as bitcoin.Network;\n\n  const unsignedTx = bitcoin.Transaction.fromHex(rawTransactionHex);\n  const tx = new bitcoin.Transaction();\n  tx.version = unsignedTx.version;\n  tx.locktime = unsignedTx.locktime;\n\n  function getKeyPairByAddress(address: string) {\n    const wif = privateKeys[address];\n    if (!wif) throw new Error(`Missing private key for address: ${address}`);\n\n    try {\n      return ECPair.fromWIF(wif, COIN_NETWORK);\n    } catch (e) {\n      console.error(\"Failed to parse WIF:\", e);\n      throw e;\n    }\n  }\n\n  function getUTXO(txid: string, vout: number): IUTXO | undefined {\n    return UTXOs.find((u) => u.txid === txid && u.outputIndex === vout);\n  }\n\n  // Add inputs\n  for (let i = 0; i < unsignedTx.ins.length; i++) {\n    const input = unsignedTx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n\n    const script = Buffer.from(utxo.script, \"hex\");\n    tx.addInput(Buffer.from(input.hash), input.index, input.sequence, script);\n  }\n\n  // Add outputs\n  for (const out of unsignedTx.outs) {\n    tx.addOutput(out.script, out.value);\n  }\n\n  // Sign each input\n  for (let i = 0; i < tx.ins.length; i++) {\n    const input = tx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n\n    const keyPair = getKeyPairByAddress(utxo.address);\n    const scriptPubKey = Buffer.from(utxo.script, \"hex\");\n\n    const sighash = tx.hashForSignature(\n      i,\n      scriptPubKey,\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n    const rawSignature = keyPair.sign(sighash);\n\n    const signatureWithHashType = bitcoin.script.signature.encode(\n      Buffer.from(rawSignature),\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const pubKey = keyPair.publicKey;\n    const scriptSig = bitcoin.script.compile([\n      signatureWithHashType,\n      Buffer.from(pubKey),\n    ]);\n\n    tx.setInputScript(i, scriptSig);\n  }\n\n  return tx.toHex();\n}\n\nexport default {\n  sign,\n};\n"],"names":[],"version":3,"file":"types.d.ts.map"}