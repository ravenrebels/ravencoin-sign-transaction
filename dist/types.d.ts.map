{"mappings":"AAKA;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,EAAE,MAAM,CAAC;CACf;AAED;;;;;;;;;;GAUG;AACH,qBACE,OAAO,EAAE,KAAK,GAAG,UAAU,GAAG,KAAK,GAAG,UAAU,EAChD,iBAAiB,EAAE,MAAM,EACzB,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,EACnB,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,GAClC,MAAM,CAuGR;;;;AAED,wBAEE","sources":["index.ts"],"sourcesContent":["const bitcoin = require(\"bitcoinjs-lib\");\n\nimport { rvn, evr, toBitcoinJS } from \"@hyperbitjs/chains\";\n\n// UTXO model for inputs to be signed\ninterface IUTXO {\n  address: string; // Address that holds the UTXO\n  assetName: string; // Name of the asset\n  txid: string; // Transaction ID of the UTXO\n  outputIndex: number; // Output index in the original transaction\n  script: string; // Hex-encoded scriptPubKey (from the UTXO)\n  satoshis: number; // Amount in satoshis\n  height?: number; // Optional block height\n  value: number; // Same as satoshis (can be used for clarity)\n}\n\n/**\n * Signs a raw, unsigned transaction using provided UTXOs and private keys.\n * Supports Ravencoin and Evrmore transactions, including asset transfers.\n * Uses bitcoinjs-lib's Transaction class directly for full script control.\n *\n * @param network - The blockchain network: 'rvn', 'rvn-test', 'evr', or 'evr-test'\n * @param rawTransactionHex - The raw hex of the unsigned transaction\n * @param UTXOs - List of UTXOs referenced by the inputs in the transaction\n * @param privateKeys - Object mapping addresses to their corresponding WIF private keys\n * @returns The signed transaction in hex format\n */\nexport function sign(\n  network: \"rvn\" | \"rvn-test\" | \"evr\" | \"evr-test\",\n  rawTransactionHex: string,\n  UTXOs: Array<IUTXO>,\n  privateKeys: Record<string, string>\n): string {\n  // Get bitcoinjs-lib-compatible network parameters\n  const networkMapper = {\n    rvn: rvn.mainnet,\n    \"rvn-test\": rvn.testnet,\n    evr: evr.mainnet,\n    \"evr-test\": evr.testnet,\n  };\n\n  const coin = networkMapper[network];\n\n  if (!coin) {\n    throw new Error(\"Invalid network specified\");\n  }\n\n  // Convert to bitcoinjs-lib network format\n  // @ts-ignore because toBitcoinJS returns a compatible structure\n  const COIN = toBitcoinJS(coin);\n\n  // Parse the unsigned transaction\n  const unsignedTx = bitcoin.Transaction.fromHex(rawTransactionHex);\n  const tx = new bitcoin.Transaction();\n\n  tx.version = unsignedTx.version;\n  tx.locktime = unsignedTx.locktime;\n\n  // Helper to look up the correct private key by address\n  function getKeyPairByAddress(address: string) {\n    const wif = privateKeys[address];\n    if (!wif) {\n      throw new Error(`Missing private key for address: ${address}`);\n    }\n    if (!COIN.messagePrefix) {\n      throw new Error(`Missing messagePrefix for coin ${COIN.name}`);\n    }\n    //@ts-ignore\n    return bitcoin.ECPair.fromWIF(wif, COIN);\n  }\n\n  // Helper to find the correct UTXO for an input\n  function getUTXO(txid: string, vout: number): IUTXO | undefined {\n    return UTXOs.find((u) => u.txid === txid && u.outputIndex === vout);\n  }\n\n  // Add all inputs to the new transaction using the actual scriptPubKey from the UTXO\n  for (let i = 0; i < unsignedTx.ins.length; i++) {\n    const input = unsignedTx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) {\n      throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n    }\n\n    const script = Buffer.from(utxo.script, \"hex\");\n\n    // Add input with the correct scriptPubKey\n    tx.addInput(Buffer.from(input.hash), input.index, input.sequence, script);\n  }\n\n  // Copy all outputs from the unsigned transaction\n  for (const out of unsignedTx.outs) {\n    tx.addOutput(out.script, out.value);\n  }\n\n  // Sign each input manually\n  for (let i = 0; i < tx.ins.length; i++) {\n    const input = tx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) {\n      throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n    }\n\n    const keyPair = getKeyPairByAddress(utxo.address);\n\n    // Compute the sighash (message to be signed)\n    const sighash = tx.hashForSignature(\n      i,\n      Buffer.from(utxo.script, \"hex\"),\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    // Sign the hash\n    const signature = bitcoin.script.signature.encode(\n      keyPair.sign(sighash),\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const pubKey = keyPair.publicKey;\n\n    // Build the unlocking script (scriptSig) manually: <signature> <pubKey>\n    const scriptSig = bitcoin.script.compile([signature, pubKey]);\n\n    // Attach the scriptSig to the input\n    tx.setInputScript(i, scriptSig);\n  }\n\n  // Return the signed transaction as hex\n  return tx.toHex();\n}\n\nexport default {\n  sign,\n};\n"],"names":[],"version":3,"file":"types.d.ts.map"}