{"mappings":"AAIA;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,EAAE,MAAM,CAAC;CACf;AAED;;;;;;;;;;GAUG;AACH,qBACE,OAAO,EAAE,KAAK,GAAG,UAAU,GAAG,KAAK,GAAG,UAAU,EAChD,iBAAiB,EAAE,MAAM,EACzB,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,EACnB,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,GAClC,MAAM,CAgGR;;;;AAED,wBAEE","sources":["index.ts"],"sourcesContent":["const bitcoin = require(\"bitcoinjs-lib\");\r\nimport { chains, toBitcoinJS } from \"@hyperbitjs/chains\";\r\n\r\n// UTXO model for inputs to be signed\r\ninterface IUTXO {\r\n  address: string;         // Address that holds the UTXO\r\n  assetName: string;       // Name of the asset \r\n  txid: string;            // Transaction ID of the UTXO\r\n  outputIndex: number;     // Output index in the original transaction\r\n  script: string;          // Hex-encoded scriptPubKey (from the UTXO)\r\n  satoshis: number;        // Amount in satoshis\r\n  height?: number;         // Optional block height\r\n  value: number;           // Same as satoshis (can be used for clarity)\r\n}\r\n\r\n/**\r\n * Signs a raw, unsigned transaction using provided UTXOs and private keys.\r\n * Supports Ravencoin and Evrmore transactions, including asset transfers.\r\n * Uses bitcoinjs-lib's Transaction class directly for full script control.\r\n *\r\n * @param network - The blockchain network: 'rvn', 'rvn-test', 'evr', or 'evr-test'\r\n * @param rawTransactionHex - The raw hex of the unsigned transaction\r\n * @param UTXOs - List of UTXOs referenced by the inputs in the transaction\r\n * @param privateKeys - Object mapping addresses to their corresponding WIF private keys\r\n * @returns The signed transaction in hex format\r\n */\r\nexport function sign(\r\n  network: \"rvn\" | \"rvn-test\" | \"evr\" | \"evr-test\",\r\n  rawTransactionHex: string,\r\n  UTXOs: Array<IUTXO>,\r\n  privateKeys: Record<string, string>\r\n): string {\r\n  // Get bitcoinjs-lib-compatible network parameters\r\n  const networkMapper = {\r\n    rvn: chains.rvn.main,\r\n    \"rvn-test\": chains.rvn.test,\r\n    evr: chains.evr.main,\r\n    \"evr-test\": chains.evr.test,\r\n  };\r\n\r\n  const coin = networkMapper[network];\r\n  if (!coin) {\r\n    throw new Error(\"Invalid network specified\");\r\n  }\r\n\r\n  // Convert to bitcoinjs-lib network format\r\n  // @ts-ignore because toBitcoinJS returns a compatible structure\r\n  const RAVENCOIN = toBitcoinJS(coin);\r\n\r\n  // Parse the unsigned transaction\r\n  const unsignedTx = bitcoin.Transaction.fromHex(rawTransactionHex);\r\n  const tx = new bitcoin.Transaction();\r\n\r\n  tx.version = unsignedTx.version;\r\n  tx.locktime = unsignedTx.locktime;\r\n\r\n  // Helper to look up the correct private key by address\r\n  function getKeyPairByAddress(address: string) {\r\n    const wif = privateKeys[address];\r\n    if (!wif) throw new Error(`Missing private key for address: ${address}`);\r\n    return bitcoin.ECPair.fromWIF(wif, RAVENCOIN);\r\n  }\r\n\r\n  // Helper to find the correct UTXO for an input\r\n  function getUTXO(txid: string, vout: number): IUTXO | undefined {\r\n    return UTXOs.find((u) => u.txid === txid && u.outputIndex === vout);\r\n  }\r\n\r\n  // Add all inputs to the new transaction using the actual scriptPubKey from the UTXO\r\n  for (let i = 0; i < unsignedTx.ins.length; i++) {\r\n    const input = unsignedTx.ins[i];\r\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\r\n    const vout = input.index;\r\n\r\n    const utxo = getUTXO(txid, vout);\r\n    if (!utxo) {\r\n      throw new Error(`Missing UTXO for input ${txid}:${vout}`);\r\n    }\r\n\r\n    const script = Buffer.from(utxo.script, \"hex\");\r\n\r\n    // Add input with the correct scriptPubKey\r\n    tx.addInput(Buffer.from(input.hash), input.index, input.sequence, script);\r\n  }\r\n\r\n  // Copy all outputs from the unsigned transaction\r\n  for (const out of unsignedTx.outs) {\r\n    tx.addOutput(out.script, out.value);\r\n  }\r\n\r\n  // Sign each input manually\r\n  for (let i = 0; i < tx.ins.length; i++) {\r\n    const input = tx.ins[i];\r\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\r\n    const vout = input.index;\r\n\r\n    const utxo = getUTXO(txid, vout);\r\n    if (!utxo) {\r\n      throw new Error(`Missing UTXO for input ${txid}:${vout}`);\r\n    }\r\n\r\n    const keyPair = getKeyPairByAddress(utxo.address);\r\n\r\n    // Compute the sighash (message to be signed)\r\n    const sighash = tx.hashForSignature(\r\n      i,\r\n      Buffer.from(utxo.script, \"hex\"),\r\n      bitcoin.Transaction.SIGHASH_ALL\r\n    );\r\n\r\n    // Sign the hash\r\n    const signature = bitcoin.script.signature.encode(\r\n      keyPair.sign(sighash),\r\n      bitcoin.Transaction.SIGHASH_ALL\r\n    );\r\n\r\n    const pubKey = keyPair.publicKey;\r\n\r\n    // Build the unlocking script (scriptSig) manually: <signature> <pubKey>\r\n    const scriptSig = bitcoin.script.compile([signature, pubKey]);\r\n\r\n    // Attach the scriptSig to the input\r\n    tx.setInputScript(i, scriptSig);\r\n  }\r\n\r\n  // Return the signed transaction as hex\r\n  return tx.toHex();\r\n}\r\n\r\nexport default {\r\n  sign,\r\n};\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}