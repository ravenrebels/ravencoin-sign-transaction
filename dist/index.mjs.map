{"mappings":";;;;;;;;;AAMA,MAAM,+BAAS,CAAA,GAAA,oBAAY,EAAE,CAAA,GAAA,4BAAE;AAaxB,SAAS,0CACd,OAAgD,EAChD,iBAAyB,EACzB,KAAmB,EACnB,WAAmC;IAEnC,MAAM,gBAAgB;QACpB,KAAK,CAAA,GAAA,kBAAU,EAAE,CAAA,GAAA,UAAE,EAAE,OAAO;QAC5B,YAAY,CAAA,GAAA,kBAAU,EAAE,CAAA,GAAA,UAAE,EAAE,OAAO;QACnC,KAAK,CAAA,GAAA,kBAAU,EAAE,CAAA,GAAA,UAAE,EAAE,OAAO;QAC5B,YAAY,CAAA,GAAA,kBAAU,EAAE,CAAA,GAAA,UAAE,EAAE,OAAO;IACrC;IAEA,MAAM,OAAO,aAAa,CAAC,QAAQ;IACnC,KAAK,MAAM,GAAG,KAAK,MAAM,IAAI,IAAI,4CAA4C;IAC7E,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,MAAM,eAAe;IAErB,MAAM,aAAa,mBAAoB,OAAO,CAAC;IAC/C,MAAM,KAAK,IAAI;IACf,GAAG,OAAO,GAAG,WAAW,OAAO;IAC/B,GAAG,QAAQ,GAAG,WAAW,QAAQ;IAEjC,SAAS,oBAAoB,OAAe;QAC1C,MAAM,MAAM,WAAW,CAAC,QAAQ;QAChC,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,SAAS;QAEvE,IAAI;YACF,OAAO,6BAAO,OAAO,CAAC,KAAK;QAC7B,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC,wBAAwB;YACtC,MAAM;QACR;IACF;IAEA,SAAS,QAAQ,IAAY,EAAE,IAAY;QACzC,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK,QAAQ,EAAE,WAAW,KAAK;IAChE;IAEA,aAAa;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,GAAG,CAAC,MAAM,EAAE,IAAK;QAC9C,MAAM,QAAQ,WAAW,GAAG,CAAC,EAAE;QAC/B,MAAM,OAAO,OAAO,IAAI,CAAC,MAAM,IAAI,EAAE,OAAO,GAAG,QAAQ,CAAC;QACxD,MAAM,OAAO,MAAM,KAAK;QAExB,MAAM,OAAO,QAAQ,MAAM;QAC3B,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,KAAK,CAAC,EAAE,MAAM;QAEnE,MAAM,SAAS,OAAO,IAAI,CAAC,KAAK,MAAM,EAAE;QACxC,GAAG,QAAQ,CAAC,OAAO,IAAI,CAAC,MAAM,IAAI,GAAG,MAAM,KAAK,EAAE,MAAM,QAAQ,EAAE;IACpE;IAEA,cAAc;IACd,KAAK,MAAM,OAAO,WAAW,IAAI,CAC/B,GAAG,SAAS,CAAC,IAAI,MAAM,EAAE,IAAI,KAAK;IAGpC,kBAAkB;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,CAAC,MAAM,EAAE,IAAK;QACtC,MAAM,QAAQ,GAAG,GAAG,CAAC,EAAE;QACvB,MAAM,OAAO,OAAO,IAAI,CAAC,MAAM,IAAI,EAAE,OAAO,GAAG,QAAQ,CAAC;QACxD,MAAM,OAAO,MAAM,KAAK;QAExB,MAAM,OAAO,QAAQ,MAAM;QAC3B,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,KAAK,CAAC,EAAE,MAAM;QAEnE,MAAM,UAAU,oBAAoB,KAAK,OAAO;QAChD,MAAM,eAAe,OAAO,IAAI,CAAC,KAAK,MAAM,EAAE;QAE9C,MAAM,UAAU,GAAG,gBAAgB,CACjC,GACA,cACA,mBAAoB,WAAW;QAEjC,MAAM,eAAe,QAAQ,IAAI,CAAC;QAElC,MAAM,wBAAwB,cAAe,SAAS,CAAC,MAAM,CAC3D,OAAO,IAAI,CAAC,eACZ,mBAAoB,WAAW;QAGjC,MAAM,SAAS,QAAQ,SAAS;QAChC,MAAM,YAAY,cAAe,OAAO,CAAC;YACvC;YACA,OAAO,IAAI,CAAC;SACb;QAED,GAAG,cAAc,CAAC,GAAG;IACvB;IAEA,OAAO,GAAG,KAAK;AACjB;IAEA,2CAAe;UACb;AACF","sources":["index.ts"],"sourcesContent":["import * as bitcoin from \"bitcoinjs-lib\";\nimport { ECPairFactory } from \"ecpair\";\nimport ecc from \"@bitcoinerlab/secp256k1\";\n\nimport { rvn, evr, toBitcoinJS, MainNet, TestNet } from \"@hyperbitjs/chains\";\n\nconst ECPair = ECPairFactory(ecc);\n\ninterface IUTXO {\n  address: string;\n  assetName: string;\n  txid: string;\n  outputIndex: number;\n  script: string;\n  satoshis: number;\n  height?: number;\n  value: number;\n}\n\nexport function sign(\n  network: \"rvn\" | \"rvn-test\" | \"evr\" | \"evr-test\",\n  rawTransactionHex: string,\n  UTXOs: Array<IUTXO>,\n  privateKeys: Record<string, string>\n): string {\n  const networkMapper = {\n    rvn: toBitcoinJS(rvn.mainnet as MainNet),\n    \"rvn-test\": toBitcoinJS(rvn.testnet as TestNet),\n    evr: toBitcoinJS(evr.mainnet as MainNet),\n    \"evr-test\": toBitcoinJS(evr.testnet as TestNet),\n  };\n\n  const COIN = networkMapper[network];\n  COIN.bech32 = COIN.bech32 || \"\"; //ECPair requires bech32 to not be undefined\n  if (!COIN) throw new Error(\"Invalid network specified\");\n\n  const COIN_NETWORK = COIN as bitcoin.Network;\n\n  const unsignedTx = bitcoin.Transaction.fromHex(rawTransactionHex);\n  const tx = new bitcoin.Transaction();\n  tx.version = unsignedTx.version;\n  tx.locktime = unsignedTx.locktime;\n\n  function getKeyPairByAddress(address: string) {\n    const wif = privateKeys[address];\n    if (!wif) throw new Error(`Missing private key for address: ${address}`);\n\n    try {\n      return ECPair.fromWIF(wif, COIN_NETWORK);\n    } catch (e) {\n      console.error(\"Failed to parse WIF:\", e);\n      throw e;\n    }\n  }\n\n  function getUTXO(txid: string, vout: number): IUTXO | undefined {\n    return UTXOs.find((u) => u.txid === txid && u.outputIndex === vout);\n  }\n\n  // Add inputs\n  for (let i = 0; i < unsignedTx.ins.length; i++) {\n    const input = unsignedTx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n\n    const script = Buffer.from(utxo.script, \"hex\");\n    tx.addInput(Buffer.from(input.hash), input.index, input.sequence, script);\n  }\n\n  // Add outputs\n  for (const out of unsignedTx.outs) {\n    tx.addOutput(out.script, out.value);\n  }\n\n  // Sign each input\n  for (let i = 0; i < tx.ins.length; i++) {\n    const input = tx.ins[i];\n    const txid = Buffer.from(input.hash).reverse().toString(\"hex\");\n    const vout = input.index;\n\n    const utxo = getUTXO(txid, vout);\n    if (!utxo) throw new Error(`Missing UTXO for input ${txid}:${vout}`);\n\n    const keyPair = getKeyPairByAddress(utxo.address);\n    const scriptPubKey = Buffer.from(utxo.script, \"hex\");\n\n    const sighash = tx.hashForSignature(\n      i,\n      scriptPubKey,\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n    const rawSignature = keyPair.sign(sighash);\n\n    const signatureWithHashType = bitcoin.script.signature.encode(\n      Buffer.from(rawSignature),\n      bitcoin.Transaction.SIGHASH_ALL\n    );\n\n    const pubKey = keyPair.publicKey;\n    const scriptSig = bitcoin.script.compile([\n      signatureWithHashType,\n      Buffer.from(pubKey),\n    ]);\n\n    tx.setInputScript(i, scriptSig);\n  }\n\n  return tx.toHex();\n}\n\nexport default {\n  sign,\n};\n"],"names":[],"version":3,"file":"index.mjs.map"}